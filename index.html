<!DOCTYPE html>
<html lang="en">

<head>
  <!-- Google tag gtag.js -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-FWXMHTS3R3"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'G-FWXMHTS3R3');
  </script>

  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Favicon -->
  <link rel="icon" href="https://raw.githubusercontent.com/chumpblocckami/merchantscroll/main/assets/favicon.ico"
    type="image/x-icon" />

  <!-- Primary Meta Tags -->
  <title>Merchant Scroll – Scroll Infinite Magic: The Gathering Decks</title>
  <meta name="title" content="Merchant Scroll – Scroll Infinite Magic: The Gathering Decks" />
  <meta name="description"
    content="Explore endless Magic: The Gathering decks across Pauper, Modern, Legacy, and more. Updated hourly for the latest meta insights." />

  <!-- Open Graph -->
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://merchant-scroll.com" />
  <meta property="og:title" content="Merchant Scroll – Scroll Infinite Magic: The Gathering Decks" />
  <meta property="og:description"
    content="Explore endless Magic: The Gathering decks across Pauper, Modern, Legacy, and more. Updated hourly for the latest meta insights." />
  <meta property="og:image"
    content="https://raw.githubusercontent.com/chumpblocckami/merchantscroll/main/assets/preview.jpg" />

  <!-- Twitter -->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="Merchant Scroll – Scroll Infinite Magic: The Gathering Decks" />
  <meta name="twitter:description"
    content="Explore endless Magic: The Gathering decks across Pauper, Modern, Legacy, and more. Updated hourly for the latest meta insights." />
  <meta name="twitter:image"
    content="https://raw.githubusercontent.com/chumpblocckami/merchantscroll/main/assets/preview.jpg" />

  <!-- Google -->
  <script type="application/ld+json">
  {
    "@context":"https://schema.org",
    "@type":"WebSite",
    "name":"Merchant Scroll",
    "url":"https://merchant-scroll.com",
    "logo":"https://raw.githubusercontent.com/chumpblocckami/merchantscroll/main/assets/preview.jpg",
    "potentialAction":{
      "@type":"SearchAction",
      "target":"https://merchant-scroll.com",
      "query-input":"required name=search_term_string"
    }
  }
  </script>

  <link rel="canonical" href="https://merchant-scroll.com/" />
  <link rel="stylesheet" href="style.css">
  <style>
    .loader {
      padding: 10px;
      text-align: center;
      font-style: italic;
    }

    .iframe-wrapper {
      width: 100%;
      height: min(88vh, 1200px);
      border: 0;
      overflow: auto;
      /* Restored to auto so content isn't cut off */
      position: relative;
    }

    .deck-frame {
      width: 100%;
      height: 100%;
      border: 0;
      background: #fff;
      overflow: auto;
      /* Keep internal scrolling for iframe content */
    }

    /* Add overlay for scroll capture */
    .scroll-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 10;
      pointer-events: none;
      /* Allow clicks through but capture scroll */
    }

    .scroll-overlay.capture-scroll {
      pointer-events: auto;
    }
  </style>
</head>

<body>
  <div class="header-container">
    <h1>Merchant Scroll</h1>
    <strong>Scroll infinite Magic: The Gathering decks</strong>
    <div class="format-selector">
      <label for="format-select"><strong>Format:</strong></label>
      <select id="format-select" name="format">
        <option value="pauper" selected>Pauper</option>
      </select>
    </div>
    <div class="info" id="info">Last update: </div>
    <div class="info" id="available-decks">Available decks: </div>
  </div>

  <div id="content" class="image-container">
    <div class="loader" id="loader">Loading...</div>
  </div>

  <footer>
    <span>Powered by</span>
    <img src="https://raw.githubusercontent.com/chumpblocckami/merchantscroll/main/assets/logo.png"
      alt="Wizards Cottage" class="footer-logo">
  </footer>

  <script>
    const content = document.getElementById("content");
    const loader = document.getElementById("loader");

    const fileBase = "https://raw.githubusercontent.com/chumpblocckami/merchantscroll/";
    const formats = {
      pauper: "main/assets/pauper/decklists.txt",
    };

    let entries = [];
    let index = 0;
    let currentScrollOverlay = null;
    let isIframeContent = false;

    function isImageUrl(url) {
      return /\.(png|jpg|jpeg|webp|gif)(\?.*)?$/i.test(url);
    }

    function clearView() {
      content.innerHTML = "";
      content.appendChild(loader);
      loader.style.display = "block";
      loader.textContent = "Loading...";
      isIframeContent = false;
      if (currentScrollOverlay) {
        currentScrollOverlay.remove();
        currentScrollOverlay = null;
      }
    }

    function createScrollOverlay(iframeWrapper) {
      const overlay = document.createElement("div");
      overlay.className = "scroll-overlay";
      iframeWrapper.appendChild(overlay);
      return overlay;
    }

    function checkIframeScrollability(iframe, overlay) {
      try {
        const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
        const hasVerticalScroll = iframeDoc.documentElement.scrollHeight > iframeDoc.documentElement.clientHeight;

        if (hasVerticalScroll) {
          // Content is scrollable, allow normal iframe scrolling
          overlay.classList.remove("capture-scroll");
          return false;
        } else {
          // Content fits, capture scroll for navigation
          overlay.classList.add("capture-scroll");
          return true;
        }
      } catch (e) {
        // Cross-origin or other access issues, assume scrollable
        overlay.classList.remove("capture-scroll");
        return false;
      }
    }

    function handleIframeScroll(iframe, overlay, event) {
      try {
        const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
        const element = iframeDoc.documentElement;
        const atTop = element.scrollTop <= 0;
        const atBottom = element.scrollTop + element.clientHeight >= element.scrollHeight - 1;

        if (event.deltaY > 0 && atBottom) {
          // Scrolling down at bottom
          event.preventDefault();
          handleScroll("next");
        } else if (event.deltaY < 0 && atTop) {
          // Scrolling up at top
          event.preventDefault();
          handleScroll("prev");
        }
      } catch (e) {
        // Cross-origin, fall back to overlay capture
        event.preventDefault();
        if (event.deltaY > 0) handleScroll("next");
        else handleScroll("prev");
      }
    }

    function showItemAtIndex(i) {
      if (i < 0 || i >= entries.length) {
        loader.textContent = "No more entries.";
        return;
      }

      const next = () => {
        console.warn("Moving to next entry:", url);
        if (i < entries.length - 1) {
          showItemAtIndex(i + 1);
        } else {
          loader.textContent = "No more entries.";
        }
      };

      clearView();

      let url = entries[i];
      console.log(url);

      if (isImageUrl(url)) {
        isIframeContent = false;
        const img = document.createElement("img");
        img.onerror = () => {
          console.warn("Image load error:", url);
          next();
        };
        img.onload = () => loader.style.display = "none";
        img.src = url;
        img.className = "card-image";
        content.appendChild(img);
      } else {
        isIframeContent = true;

        // Create iframe wrapper
        const wrapper = document.createElement("div");
        wrapper.className = "iframe-wrapper";

        const frame = document.createElement("iframe");
        frame.className = "deck-frame";
        frame.setAttribute("sandbox", "allow-scripts allow-forms allow-popups allow-same-origin");

        wrapper.appendChild(frame);
        content.appendChild(wrapper);

        // Create scroll overlay
        currentScrollOverlay = createScrollOverlay(wrapper);

        const onFrameLoad = () => {
          // Check if iframe loaded successfully and has content
          setTimeout(() => {
            try {
              const iframeDoc = frame.contentDocument || frame.contentWindow.document;
              const bodyContent = iframeDoc.body ? iframeDoc.body.innerText.trim() : '';
              const hasTitle = iframeDoc.title && iframeDoc.title.trim().length > 0;
              const hasContent = bodyContent.length > 10; // Minimum content threshold

              if (!hasContent && !hasTitle) {
                console.warn("Empty or invalid content:", url);
                next();
                return;
              }

              loader.style.display = "none";

              const captureScroll = checkIframeScrollability(frame, currentScrollOverlay);

              if (!captureScroll) {
                // Set up scroll monitoring for iframe content
                iframeDoc.addEventListener("wheel", (event) => {
                  handleIframeScroll(frame, currentScrollOverlay, event);
                }, { passive: false });
              }
            } catch (e) {
              // Cross-origin or access error, assume it's valid content but use overlay
              console.warn("Cross-origin iframe or access error, assuming valid content:", url);
              loader.style.display = "none";
              currentScrollOverlay.classList.add("capture-scroll");
            }
          }, 200);
        };

        const onFrameError = () => {
          console.warn("Iframe load error:", url);
          next();
        };

        // Set up scroll handling for overlay
        currentScrollOverlay.addEventListener("wheel", (event) => {
          if (currentScrollOverlay.classList.contains("capture-scroll")) {
            event.preventDefault();
            if (event.deltaY > 0) handleScroll("next");
            else handleScroll("prev");
          }
        }, { passive: false });

        // Try fetching and injecting with a base tag
        fetch(url, { cache: "no-store" })
          .then(res => {
            if (!res.ok) throw new Error("Fetch failed");
            return res.text();
          })
          .then(html => {
            // Check if HTML content is meaningful (not just empty or error pages)
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = html;
            const textContent = tempDiv.textContent || tempDiv.innerText || '';

            if (textContent.trim().length < 10) {
              console.warn("HTML content appears empty or too short:", url);
              next();
              return;
            }

            const baseHref = url.slice(0, url.lastIndexOf("/") + 1);
            const withBase = html.replace(/<head(\s*)>/i, `<head$1><base href="${baseHref}">`);

            frame.addEventListener("load", onFrameLoad, { once: true });
            frame.addEventListener("error", onFrameError, { once: true });

            frame.srcdoc = withBase;
          })
          .catch((error) => {
            console.warn("Fetch failed for:", url, error);
            // Fallback to direct src if fetch fails
            frame.removeAttribute("srcdoc");
            frame.src = url;
            frame.addEventListener("load", onFrameLoad, { once: true });
            frame.addEventListener("error", onFrameError, { once: true });
          });
      }
    }

    function fetchDecklist(format) {
      const fileUrl = `${fileBase}/${formats[format]}`;
      clearView();
      index = 0;
      entries = [];

      const currentYear = new Date().getFullYear().toString();

      fetch(fileUrl)
        .then(res => {
          if (!res.ok) throw new Error("Error fetching decklist.");
          return res.text();
        })
        .then(text => {
          entries = text
            .split(/\s+/)
            .map(u => u.trim())
            .filter(u => u.length > 0 && u.includes(currentYear));

          document.getElementById("available-decks").textContent =
            "Available " + format + " decks: " + entries.length;

          showItemAtIndex(index);
        })
        .catch((err) => {
          console.log(err);
          loader.textContent = "Error loading list.";
        });
    }

    // Handle format change
    document.querySelector('select[name="format"]').addEventListener("change", (e) => {
      fetchDecklist(e.target.value);
    });

    // Scroll control
    let throttle = false;
    function handleScroll(direction) {
      if (throttle) return;
      throttle = true;
      setTimeout(() => throttle = false, 500);

      if (direction === "next" && index < entries.length - 1) {
        index++;
        showItemAtIndex(index);
      } else if (direction === "prev" && index > 0) {
        index--;
        showItemAtIndex(index);
      }
    }

    // Desktop scroll for non-iframe content
    content.addEventListener("wheel", (event) => {
      // Only handle scroll here for images, not iframe content
      if (!isIframeContent) {
        event.preventDefault();
        if (event.deltaY > 0) handleScroll("next");
        else handleScroll("prev");
      }
    }, { passive: false });

    // Mobile swipe
    let touchStartY = 0;
    let touchEndY = 0;
    content.addEventListener("touchstart", (e) => {
      touchStartY = e.changedTouches[0].screenY;
    });
    content.addEventListener("touchend", (e) => {
      touchEndY = e.changedTouches[0].screenY;
      const deltaY = touchStartY - touchEndY;
      if (Math.abs(deltaY) > 50) {
        if (deltaY > 0) handleScroll("next");
        else handleScroll("prev");
      }
    });

    // Initial load
    fetchDecklist("pauper");

    // Last update info
    const updateDiv = document.getElementById("info");
    fetch("https://raw.githubusercontent.com/chumpblocckami/merchantscroll/refs/heads/main/info.json")
      .then(res => res.ok ? res.json() : Promise.reject("Could not fetch last update."))
      .then(data => updateDiv.textContent = data.last_update ? `Last update: ${data.last_update}` : "No update info.")
      .catch(() => updateDiv.textContent = "Error loading update info.");
  </script>

</body>

</html>
